--- acpi_ibm.c.orig 2018-06-18 20:05:09.510966000 +0200
+++ acpi_ibm.c  2018-06-18 20:02:43.835109000 +0200
@@ -349,7 +349,7 @@
 DRIVER_MODULE(acpi_ibm, acpi, acpi_ibm_driver, acpi_ibm_devclass,
          0, 0);
 MODULE_DEPEND(acpi_ibm, acpi, 1, 1, 1);
-static char    *ibm_ids[] = {"IBM0068", "LEN0068", NULL};
+static char    *ibm_ids[] = {"IBM0068", "LEN0068", "LEN0268", NULL};
 
 static void
 ibm_led(void *softc, int onoff)
@@ -425,9 +425,14 @@
 acpi_ibm_attach(device_t dev)
 {
    int i;
+   int hkey;
    struct acpi_ibm_softc   *sc;
    char *maker, *product;
-   devclass_t      ec_devclass;
+   ACPI_OBJECT_LIST input;
+   ACPI_OBJECT params[1];
+   ACPI_OBJECT out_obj;
+   ACPI_BUFFER result;
+   devclass_t ec_devclass;
 
    ACPI_FUNCTION_TRACE((char *)(uintptr_t) __func__);
 
@@ -456,21 +461,54 @@
    sc->events_mask_supported = ACPI_SUCCESS(acpi_GetInteger(sc->handle,
        IBM_NAME_EVENTS_MASK_GET, &sc->events_initialmask));
 
+        if (ACPI_SUCCESS (acpi_GetInteger(sc->handle, "MHKV", &hkey)))
+   {
+       device_printf(dev, "Firmware version key 0x%X\n", hkey);
+   }
+   else
+   {
+       device_printf(dev, "Failed to get firmware version key\n");
+       return (EINVAL);
+   }
+
    if (sc->events_mask_supported) {
        SYSCTL_ADD_UINT(sc->sysctl_ctx,
            SYSCTL_CHILDREN(sc->sysctl_tree), OID_AUTO,
            "initialmask", CTLFLAG_RD,
            &sc->events_initialmask, 0, "Initial eventmask");
 
-       /* The availmask is the bitmask of supported events */
-       if (ACPI_FAILURE(acpi_GetInteger(sc->handle,
-           IBM_NAME_EVENTS_AVAILMASK, &sc->events_availmask)))
-           sc->events_availmask = 0xffffffff;
+       switch(hkey >> 8)
+       {
+           case 1:
+               /* The availmask is the bitmask of supported events */
+               if (ACPI_FAILURE(acpi_GetInteger(sc->handle,
+                               IBM_NAME_EVENTS_AVAILMASK, &sc->events_availmask)))
+                   sc->events_availmask = 0xffffffff;
 
+               break;
+
+           case 2:
+               result.Length = sizeof(out_obj);
+               result.Pointer = &out_obj;
+               params[0].Type = ACPI_TYPE_INTEGER;
+               params[0].Integer.Value = 1;
+               input.Pointer = params;
+               input.Count = 1;
+
+               sc->events_availmask = 0xffffffff;
+
+               if (ACPI_SUCCESS(AcpiEvaluateObject (sc->handle,
+                       IBM_NAME_EVENTS_AVAILMASK, &input, &result)))
+                   sc->events_availmask = out_obj.Integer.Value;
+               break;
+
+           default:
+           break;
+       }
        SYSCTL_ADD_UINT(sc->sysctl_ctx,
-           SYSCTL_CHILDREN(sc->sysctl_tree), OID_AUTO,
-           "availmask", CTLFLAG_RD,
-           &sc->events_availmask, 0, "Mask of supported events");
+               SYSCTL_CHILDREN(sc->sysctl_tree), OID_AUTO,
+               "availmask", CTLFLAG_RD,
+               &sc->events_availmask, 0, "Mask of supported events");
    }
 
    /* Hook up proc nodes */
